# h5 It's Alive! 
Kotitehtävä h5 It's Alive! Tero Karvisen & Lari Iso-Anttilan Sovellusten hakkerointi ja haavoittuvuudet 2026 kevät -kurssille. [Linkki kurssisivulle](https://terokarvinen.com/application-hacking/)
Jokaisessa kohdassa on alla olevalla "quote" tyylillä kerrottu tehtävänanto.
>Liirum laarum laa...
## a
> a) Lab1. Investigate what's wrong with the program and how to fix it. lab1.zip

Aluksi tein uuden kansion, mihin tekisin tämän viikon tehtävät. Tämän jälkeen latasin ``lab1.zip`` tiedoston ja unzippasin sen.

![alt text](image.png)

![alt text](image-1.png)

Kali 2025.4 mukana ei ollut tullut valmiiksi gdb, joten asensin sen `sudo apt gdb`. Koitin suorittaa gdb_example1 binaaria, mutta se antoi tällaisen outputin sekä errorin.

![alt text](image-2.png)

Segmentation fault tarkoittaa sitä, kun ohjelma yrittää käyttää sellaista muistisijaintia, mihin sillä ei ole oikeutta (Stackoverflow What is a segmentation fault?
, https://stackoverflow.com/questions/2346806/what-is-a-segmentation-fault#:~:text=A%20segmentation%20fault%20is%20a%20type%20of,execute%20a%20program%20that%20doesn't%20compile%20correctly). 

Itse koodi näyttää tältä:
    gdb gdb_example1
    list

![alt text](image-3.png)

Tuossa näkyi vain main funktio, mutta ei koko koodia. Sen sain näkyville kirjoittamalla `tui layout next` ja painamalla enteria muutaman kerran. 

![alt text](image-4.png)

![alt text](image-5.png)

Tämän jälkeen aloin debuggaamaan. 

    break main
    run
    next

Kirjoitin next niin kauan, kunnes tuli error. 

![alt text](image-6.png)

Oma ymmärrys tästä koko koodista on seuraava (kahdesta aikaisemmasta kuvasta näkee source koodin). Koodi mallintaa Caesar cipheria. Koodi muuttaa halutun sanan merkit (tässä tapauksessa "Hello World") halutulla määrällä (+3) eteenpäin. Koodi toimii siihen mennessä hyvin, kunnes sen pitää printata `bad_message`. Koska bad_message on tyhjä, ei ohjelma pysty printata mitän, koska tämä osoittaa ei mihinkään (NULL). Testasin aluksi helpointa vaihtoehtoa, eli kommentoin vaan pois main funktiosta seuraavat rivit. En muokannut alkuperäistä koodia, vaan aluksi tein kopion fix.c.

![alt text](image-7.png)

Compilasin koodin ja suoritin sen. Nyt ei tullut ainaskaan segemntation fault viesitä.

![alt text](image-8.png)

Testasin myös toimiiko bad_messagen printtaaminen jos siihen pistää merkkejä, eikä se ole vain NULL.

![alt text](image-9.png)

![alt text](image-10.png)

Ohjelma siis toimii nyt hyvin, joko laittaa bad_messageen tekstiä tai kommentoi pois rivit, jossa sen muokkaamista kutsutaan sekä sen tulostusta. Nämä molemmat olivat vähän huonoja ratkaisuja eivätkä sinänsä vastaa suoraan ongelmaan. Kysyin tekoälyltä (Gemini 3 Fast), miten hän korjaisi tämän ja Geminin antama korjaus on kyllä parempi tapa korjata tämä.

![alt text](image-11.png)

Tässä funktiota bad_message ei vain ns poisteta koodista tai pakoiteta sitä printtaamaan jotain. Sen sijaan tämä NULL otetaan huomioon tekemällä if lauseke. 

Gemini avulla korjattu koodi:

![alt text](image-12.png)

![alt text](image-13.png)

Tällä tavalla error on otettu kiinni ja se käsitellään, eikä sitä ole ignorattu kuin minun aikaisemmissa korjauksissa. 

## b
> Find out the password and flag + write a report on how it opened. lab2.zip

Latasin lab2.zip tiedoston ja unzippasin sen.

![alt text](image-14.png)

Alhaalla kansion README.md tiedoston sisältö,

![alt text](image-15.png)

Katsoin miten passtr toimi. Se tarkistaa käyttäjän inputin, ja jos se on haluttu sana, "sala-hakkeri-321" se printtaa tämän jälkeen flagin.

![alt text](image-21.png)

Avasin passtr2o gdb avulla ja suoritin komennon `tui layout next`. Nopeasti huomasin, että kyseistä binääriä compilatessa ei oltu käytetty debug hedereita, joten C kieltä ei tullut näkyviin vaan jouduin tyytymään assemblyyn. Alla kuva koodipätkä assemblysta.

![alt text](image-22.png)

Mietin hetken miten tätä tehtävää lähtisi selvittämään. Hetken mietittyä tulin siihen johtopäätökseen, että ohjelma mahdollisesti toimisi samalla tai miltein samalla tavalla kuin passtr. 

Seuraava ratkaisu tähän flagiin kirjoitettu jälkeenpäin itse tekemisen jälkeen, joten koitan mahdollisimman hyvin muistaa mitä tein ja miksi.

Otin aluksi molempien passtr, sekä passtr2o gdb terminaalit vierekkäin

![alt text](image-23.png)

Seuraavaksi katsoin step-by-step, miten passtr toimii ja miltä se näyttää assemblyssa,

    break main
    run
    next...

Samalla koitin katsoa, että näyttäisikö asiat samalta passtr2o:ssa, mutta ei näyttänyt ainaskaan omaan silmään. Ajatuksena olisi ollut havaita kohta, missä vertailu tapahtuu. Jos olisin löytänyt sen, niin olisin voinut löytää saman kohdan passtr2o:sta ja muuttaa sen siihen että kaikki muut paitsi oikea salasana antaa flagin. Tässä en onnistunut. Seuraavaksi kysyinkin Gemini 3 Pro:lta apua tähän seuraavalla promptilla:

![alt text](image-24.png)

Gemini sanoi, että minun pitäisi löytää assemblystä kohta `<strcmp@plt>`. Kun sen löytäisi voisin vaihtaa je (jump if equal) --> jne (jump if not equal). Alla olevassa kuvassa siis pitäisi löytä samanlainen kohta kuin `puts@plt`, mutta se olisi `strcmp@plt`. Sitä ennen minun pitäisi suorittaa komento `disassemble main`. Suoritin komennon ja koitin etsiä `strcmp@plt`

![alt text](image-25.png)

Tätä string comparea ei löytynyt assemblysta, vaan löysin seuraavat (kutsut?): 

    puts@plt , __isoc99_scanf@plt , printf@plt sekä strlen@plt

Promptasin tämän ongelman ja kuvan Geminille. Ohjeet oli vähän sekavat kun Gemini ei tiennyt minkälainen koodi on. Ohjeissa Gemini sanoi, että kannattaa katsoa ``<main>`` funktion loppua ja sieltä kohtaa, missä `puts@plt sekä print@plt` olisivat lähekkäin. Laitoinkin hänelle alla olevan kuvan, jos se auttaisi.

![alt text](image-16.png)

Kuva auttoi Geminia selvittämään tehtävän ja seurasin sen antamia ohjeita.

![alt text](image-26.png)

![alt text](image-17.png)

Tämän jälkeen run komento

![alt text](image-18.png)

Laitoin väärän salasanan, `aa` ja painoin enter.

![alt text](image-19.png)

Nyt olen oikeassa kohdassa, mistä voin muuttaa jne --> je

`set *(unsigned char*)($pc) = 0x74`
`continue`

![alt text](image-20.png)

Ja flag tuli, FLAG{Lari-rsvRDx04WMBZpuwg4qfYwzdcvVa0oym}.

Seuraavaksi salasanan aika. 

### Salasana

Pysyin Geminin kanssa samassa keskustelussa ja kysyin, miten ohjelman salaisen lauseen löytäisi. Aiemman kuvan perusteella, Gemini näki kohdan assemblysta, missä ohjelma lataa salasanan muistiin. Alla vielä kuva joka oli Geminilla

![alt text](image-16.png)


    gdb passtr2o
    disassemble main

Gemini oli havainnut, että funktio ``mAsdf3a`` on todennäköisesti se, missä ohjelma suorittaa vertaillun. Nyt vain pitäisi pistää tähän kohtaan breakpoint ja lukea muisti ennen kuin ohjelma suorittaa vertaillun. Breakpointin avulla pystyisimme siis debugata ohjelmasta kohdan, jossa ohjelma on ladannut käyttäjän antaman salasanan sekä ohjelman, mutta ei vielä vertaillut niitä. Alla Geminin antamat ohjeet.

![alt text](image-28.png)

![alt text](image-29.png)

Sain luettua salasanan `anLTj4u8`. Testasin tätä, mutta se ei toiminut

![alt text](image-30.png)

Promptasin ongelman Geminille. Seuraavaksi se ohjeisti minua keskeyttämään vertailu loopin, jolloin pystyisin näkemään salasanan. GDB:ssa suoritin komennon `disassemble mAsdf3a`, jossa `mAsdf3a` on aikaisemmin havaittu vertailufunktio.

![alt text](image-31.png)

Promptasin tämän Geminille, koska minulla ei ole mitään tietoa assemblysta. Tässä assembly koodissa

- ``<+54> test $0x1,%al`` tarkistaa kyseisen merkin indexin ja onko se tasaluku vai epätasainen, eli jakojäännös.
- Jos se on tasan, lisätään 3 alkuperäisen merkin ASC arvoon
- Jos ei niin miinustetaan 3 alkuperäisen merkin ASC arvoon

Tässä geminin antama taulukko havaistamaan tätä aikaisempaan saatuun salasanaan `anLTj4u8`

![alt text](image-32.png)

Tämän avulla sain decodatun salasanan `dgOMm-x1`

![alt text](image-27.png)

## c) Lab3. Try Nora Crackmes exercises tasks 3 and 4; the rest are optional. Tindall 2023: NoraCodes / crackmes.

Latasin tehtävät ja suoritin `make` komennon, jotta C-kielen tiedostoista tulisi .64 ajettavia binaareja.

    git clone https://github.com/NoraCodes/crackmes.git
    cd crackmes
    make

![alt text](image-33.png)

Sain gdb `disassemble main` komennon avulla tämän näköisen assembly pätkän.

![alt text](image-34.png)

Aikaisemman tehtävän perusteella tein seuraavan hypoteesin. Tässä on string length jonka alla 0x6 eli ohjelma tarkistaa salasanan ja sen koko pitää olla 6 merkkiä. Myöhemmin ``<73>`` kohdassa on check_pw eli selkeästi funktio check password. Testasin 6 merkin salasanaa, ei toiminut

![alt text](image-35.png)

Itsellä ei ole mitään tietoa miten tästä edetä, joten luovutin taas oman ajatteluni ja kysyin Geminiltä mitä tehdä. Promptissa käytin yllä olevaa kuvaa `mainista` ja kerroin että käytän GDB ja voisiko ohjelmaa muokata niin, että se hyväksyisi minkä tahansa salasanan. Tämän promptin jälkeen Gemini kertoi hyvin ympäripyöreästi miten ohjelma toimii kuvan perusteella. Sen tarkempaa vastausta se ei suostunut antamaan

![alt text](image-36.png)

Seuraavassa promptissa kerroin vähän enemmän tietoja, jotta Gemini suostuisi antamaan vastauksen.

![alt text](image-37.png)

No sehän toimi nopeasti. Tässä oli Geminin antama ohje miten nyt kaverini CTF haaste ratkaistaisiin.

![alt text](image-38.png)

![alt text](image-39.png)

Se miten tämä toimii on, että ohjelma asettaa eax arvon 0 jos salasana on väärin. Mutta GDB avulla pystyin muokkaamaan tätä, että suorituksen aikana kerroin ohjelmalle, että tämä salasana olikin oikein asettamalla eax arvon 1.  

# Lähteet
- Kurssisivu, Tero Karvinen Application Hacking: https://terokarvinen.com/application-hacking/
- Stack overflow What is a segmentation fault? https://stackoverflow.com/questions/2346806/what-is-a-segmentation-fault#:~:text=A%20segmentation%20fault%20is%20a%20type%20of,execute%20a%20program%20that%20doesn't%20compile%20correctly
- Gemini 3, modes:  Fast & Thinking
- Nora crackmes: https://github.com/NoraCodes/crackmes